# 구현내용

- 화면에서 2023년과 2024년의 유저 정보를 보여준다.
- 첫번째 버튼을 누르면 새해가 밝아져 2024년 유저의 나이에만 한 살을 더해줘야 하는데, 2023년과 2024년의 나이가 동시에 증가한다.
- 그 이유는 newUser와 user의 참조하는 주소값이 동일하여 newUser의 age를 한 살 더하여도, user의 age값이 같이 변하기 때문이다.
- 그래서 두번째 버튼을 누르면 그 버튼은 새로운 객체를 만들고, user의 프로퍼티드를 복사하는 방식이기 때문에 둘은 다른 주소값을 가지고 있어, newUser의 나이를 증가시켜도 user의 나이는 변하지 않습니다.

# 특이사항

처음에 showDeepCopyBtn 값이 없었을때는 user1과 user2가 각각 30으로 증가하여도 화면에서는 29살로 변하지 않았습니다.

(이는 alert를 통해 확인할 수 있습니다.)

하지만 showDeepCopyBtn이라는 state를 만들고 이 state를 변경해주자 화면이 재렌더링 되어 30살로 변한것을 확인하였습니다.

user1과 user2가 state이고, state가 변경되면 그 state를 가지고 있는 컴포넌트가 재렌더링 된다고 알고 있었지만, 화면이 재렌더링 되지 않은게 의문이었습니다.

검색해보니 "state가 변경된다"라는 의미는 state의 property가 변경된다는 것이 아닌 "state의 주솟값이 변경된다"는 의미이고, 이를 만족해야 컴포넌트가 재렌더링 된다는것을 알게 되었습니다.

따라서 showDeepCopyBtn의 도움을 얻어? 화면이 재렌더링 되었고, 바뀐 user1과 user2도 화면에서 볼 수 있게 된것 입니다.

그래서 다시 버튼을 눌러도 showDeepCopyBtn은 계속 true로 일정하기 때문에, 30살에서 31살, 32살되는것은 화면에서 볼 수 없는 것입니다.

객체의 가변성에 따른 문제를 공부하려던 이번 실습에서 추가로 리액트의 재렌더링 조건까지 다시 한번 명확히 이해하게 되었습니다.

## 참고

리액트의 state의 변화 감지 기준은 'Call Stack의 주소 값'

리액트는 콜스택의 주소값만을 비교하여 상태 변화를 감지합니다. 이를 '얕은 비교'라고 합니다. 리액트의 빠른 state 변화 감지를 할 수 있도록 해주는 장점이자, 불변성을 지켜야하는 이유 입니다.
얕은 비교에 대해 설명을 덧붙이자면, 원시 타입은 값을 비교하고, 참조 타입은 그 안의 값을 비교하지 않고, 참조되는 주소(위치)를 비교 합니다.

# setState의 동작 원리

"changeAge 함수 안에서 `setUser1(user)`을 해주었을때, 아래 alert의 user1.age는 뭐라고 찍힐까" 라는 질문에 29살 이라고 답했습니다.
그 이유는 setState 함수가 '한 박자 늦게 일어난다'라고 막연히 알고 있던 개념 때문에 state가 아직 변하지 않았을 것이라고 예상했습니다.
하지만 user.age는 30살로 찍혔고, setUser1(user) 부분을 주석처리 하여도 똑같이 30살로 찍혔습니다.
저는 '한 박자 늦게 일어난다'라는 말이 정확히 무슨 의미인지 알아보기 위해 setState의 동작 원리에 대해 찾아보았습니다.

setState의 동작 원리는

1. `state`가 바뀌면 화면 전체가 자동으로 다시 그려진다. (재렌더링)
2. `setState`는 비동기로 작동한다.
   state의 값은 setState가 호출되는 시점이 아닌, 해당 코드가 들어있는 함수가 모두 실행된 이후에 바뀐다.
   그 이유는, setState가 비동기가 아닌 동기로 작동하게 되면 변경될 때마다 바로바로 렌더링이 일어나서 비효율적이기 때문이다. 렌더링 횟수를 줄여 더 빠르게 동작하게 하기 위함인 것이다.

함수 안에 setState가 여러개 있으면 함수 하나를 실행시키는데 렌더링을 여러번 하게 되어서 성능상 좋지 않다.
따라서 임시 저장소에 모아두었다가 코드를 끝까지 읽고 한번에 바꿔서 렌더링 한다.

기존에 생각하고 있던 '한 박자 늦게 일어난다'는 코드가 호출되는 시점에 바로 실행되는 것이 아닌 '해당 코드가 들어있는 함수가 모두 실행된 이후에 바뀌는 비동기적 처리'를 의미한 거였습니다. (코드를 끝까지 읽은 후 한번에 업데이트)

## 예시

```
 const onClickCount = () => {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
  };
```

위 함수가 실행되면 count를 증가시키는 setCount가 4개나 있음에도 불구하고 count의 값은 1만 증가됩니다.
변경된 값이 바로 반영되는 것이 아닌, 임시 저장공간에 넣어두고, 함수가 끝나고 나서 값이 변경되기 때문입니다.

## prevState

이럴때 `prev`를 사용하면 임시 저장공간에 있는 값을 가져올 수 있다!
(임시 저장공간에 값이 없으면 default 값을 가져온다.)
prev대신 prevState를 써도 됩니다.

```
 const onClickCount = () => {
    setCount((prev) => prev + 1);
    setCount((prev) => prev + 1);
    setCount((prev) => prev + 1);
    setCount((prev) => prev + 1);
  };
```

이렇게 하면 count의 값이 setCount로 증가시킨 횟수만큼 증가합니다.

위 방식은 setCount안에 함수 자체를 넘겨주는 방식이고, 해당 함수가 리턴시키는 값을 다시 매개변수로 넣어서 최신값으로 업데이트 되기 때문입니다.

prevState는 boolean값을 변경시킬 때 편리하게 활용될 수 있다고 합니다.

## 리렌더가 되는 상황

1. 새로운 props가 들어올 때
2. 부모 컴포넌트가 렌더링 될 때
3. 강제 업데이트(forceUpdate)가 실행될 때
4. state가 변경될 때

### 참고

- https://velog.io/@e_juhee/prev-state
- https://velog.io/@matajeu/React-%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85%EA%B3%BC-setState-%EB%B0%B0%EC%97%B4%EA%B0%9D%EC%B2%B4-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC
